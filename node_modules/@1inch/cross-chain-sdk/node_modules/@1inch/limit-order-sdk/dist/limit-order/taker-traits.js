"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TakerTraits = exports.AmountMode = void 0;
const byte_utils_1 = require("@1inch/byte-utils");
const constants_1 = require("../constants");
var AmountMode;
(function (AmountMode) {
    /**
     * Amount provided to fill function treated as `takingAmount` and `makingAmount` calculated based on it
     */
    AmountMode[AmountMode["taker"] = 0] = "taker";
    /**
     * Amount provided to fill function treated as `makingAmount` and `takingAmount` calculated based on it
     */
    AmountMode[AmountMode["maker"] = 1] = "maker";
})(AmountMode = exports.AmountMode || (exports.AmountMode = {}));
/**
 * TakerTraitsLib
 * This class defines TakerTraits, which are used to encode the taker's preferences for an order in a single uint256.
 *
 * The TakerTraits are structured as follows:
 * High bits are used for flags
 * 255 bit `_MAKER_AMOUNT_FLAG`           - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.
 * 254 bit `_UNWRAP_WETH_FLAG`            - If set, the WETH will be unwrapped into ETH before sending to taker.
 * 253 bit `_SKIP_ORDER_PERMIT_FLAG`      - If set, the order skips maker's permit execution.
 * 252 bit `_USE_PERMIT2_FLAG`            - If set, the order uses the permit2 function for authorization.
 * 251 bit `_ARGS_HAS_TARGET`             - If set, then first 20 bytes of args are treated as receiver address for makerâ€™s funds transfer.
 * 224-247 bits `ARGS_EXTENSION_LENGTH`   - The length of the extension calldata in the args.
 * 200-223 bits `ARGS_INTERACTION_LENGTH` - The length of the interaction calldata in the args.
 * 0-184 bits                             - The threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).
 */
class TakerTraits {
    constructor(flag, data) {
        this.flags = new byte_utils_1.BN(flag);
        this.receiver = data.receiver;
        this.extension = data.extension;
        this.interaction = data.interaction;
    }
    static default() {
        return new TakerTraits(0n, {});
    }
    /**
     * Returns enabled amount mode, it defines how to treat passed amount in `fillContractOrderArgs` function
     *
     * @see AmountMode
     */
    getAmountMode() {
        return this.flags.getBit(TakerTraits.MAKER_AMOUNT_FLAG);
    }
    setAmountMode(mode) {
        this.flags = this.flags.setBit(TakerTraits.MAKER_AMOUNT_FLAG, mode);
        return this;
    }
    /**
     * Is the Wrapped native currency will be unwrapped into Native currency before sending to taker
     */
    isNativeUnwrapEnabled() {
        return this.flags.getBit(TakerTraits.UNWRAP_WETH_FLAG) === 1;
    }
    /**
     * Wrapped native currency will be unwrapped into Native currency before sending to taker
     */
    enableNativeUnwrap() {
        this.flags = this.flags.setBit(TakerTraits.UNWRAP_WETH_FLAG, 1);
        return this;
    }
    /**
     * Wrapped native currency will NOT be unwrapped into Native currency before sending to taker
     */
    disableNativeUnwrap() {
        this.flags = this.flags.setBit(TakerTraits.UNWRAP_WETH_FLAG, 0);
        return this;
    }
    /**
     * If true, then maker's permit execution is skipped
     */
    isOrderPermitSkipped() {
        return Boolean(this.flags.getBit(TakerTraits.SKIP_ORDER_PERMIT_FLAG));
    }
    /**
     * The order skips maker's permit execution
     */
    skipOrderPermit() {
        this.flags = this.flags.setBit(TakerTraits.SKIP_ORDER_PERMIT_FLAG, 1);
        return this;
    }
    /**
     * Should use permit2 function for authorization or not
     *
     * @see https://github.com/Uniswap/permit2
     */
    isPermit2Enabled() {
        return this.flags.getBit(TakerTraits.USE_PERMIT2_FLAG) === 1;
    }
    /**
     * Use permit2 function for authorization
     *
     * @see https://github.com/Uniswap/permit2
     */
    enablePermit2() {
        this.flags = this.flags.setBit(TakerTraits.USE_PERMIT2_FLAG, 1);
        return this;
    }
    /**
     * NOT use permit2 function for authorization
     */
    disablePermit2() {
        this.flags = this.flags.setBit(TakerTraits.USE_PERMIT2_FLAG, 0);
        return this;
    }
    /**
     * Sets address where order filled to, `msg.sender` used if not set
     *
     * @param receiver
     */
    setReceiver(receiver) {
        this.receiver = receiver;
        return this;
    }
    /**
     * Set order receiver as `msg.sender`
     */
    removeReceiver() {
        this.receiver = undefined;
        return this;
    }
    /**
     * Sets extension, it is required to provide same extension as in order creation (if any)
     */
    setExtension(ext) {
        this.extension = ext;
        return this;
    }
    removeExtension() {
        this.extension = undefined;
        return this;
    }
    /**
     * Set threshold amount
     *
     * In taker amount mode: the minimum amount a taker agrees to receive in exchange for a taking amount.
     * In maker amount mode: the maximum amount a taker agrees to give in exchange for a making amount.
     *
     * @see AmountMode
     */
    setAmountThreshold(threshold) {
        this.flags = this.flags.setMask(TakerTraits.THRESHOLD_MASK, threshold);
        return this;
    }
    /**
     * @see setAmountThreshold
     */
    removeAmountThreshold() {
        this.flags = this.flags.setMask(TakerTraits.THRESHOLD_MASK, 0n);
        return this;
    }
    /**
     * Sets taker interaction
     *
     * `interaction.target` should implement `ITakerInteraction` interface
     *
     * @see https://github.com/1inch/limit-order-protocol/blob/1a32e059f78ddcf1fe6294baed6cafb73a04b685/contracts/interfaces/ITakerInteraction.sol#L11
     */
    setInteraction(interaction) {
        this.interaction = interaction;
        return this;
    }
    removeInteraction() {
        this.interaction = undefined;
        return this;
    }
    encode() {
        const extensionLen = this.extension
            ? (0, byte_utils_1.getBytesCount)(this.extension.encode())
            : 0n;
        const interactionLen = this.interaction
            ? (0, byte_utils_1.getBytesCount)(this.interaction.encode())
            : 0n;
        const flags = this.flags
            .setBit(TakerTraits.ARGS_HAS_RECEIVER, this.receiver ? 1 : 0)
            .setMask(TakerTraits.ARGS_EXTENSION_LENGTH_MASK, extensionLen)
            .setMask(TakerTraits.ARGS_INTERACTION_LENGTH_MASK, interactionLen);
        const args = (this.receiver?.toString() || constants_1.ZX) +
            (0, byte_utils_1.trim0x)(this.extension?.encode() || '') +
            (0, byte_utils_1.trim0x)(this.interaction?.encode() || '');
        return {
            trait: flags.value,
            args
        };
    }
}
exports.TakerTraits = TakerTraits;
TakerTraits.MAKER_AMOUNT_FLAG = 255n;
TakerTraits.UNWRAP_WETH_FLAG = 254n;
TakerTraits.SKIP_ORDER_PERMIT_FLAG = 253n;
TakerTraits.USE_PERMIT2_FLAG = 252n;
TakerTraits.ARGS_HAS_RECEIVER = 251n;
TakerTraits.THRESHOLD_MASK = new byte_utils_1.BitMask(0n, 185n);
TakerTraits.ARGS_INTERACTION_LENGTH_MASK = new byte_utils_1.BitMask(200n, 224n);
TakerTraits.ARGS_EXTENSION_LENGTH_MASK = new byte_utils_1.BitMask(224n, 248n);
//# sourceMappingURL=taker-traits.js.map