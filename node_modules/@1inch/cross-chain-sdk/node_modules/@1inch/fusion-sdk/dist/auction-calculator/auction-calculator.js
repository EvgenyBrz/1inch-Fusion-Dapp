"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuctionCalculator = void 0;
const constants_1 = require("./constants");
const sdk_1 = require("../sdk");
class AuctionCalculator {
    constructor(startTime, duration, initialRateBump, points, takerFeeRatio, gasCost = {
        gasBumpEstimate: 0n,
        gasPriceEstimate: 0n
    }) {
        this.startTime = startTime;
        this.duration = duration;
        this.initialRateBump = initialRateBump;
        this.points = points;
        this.takerFeeRatio = takerFeeRatio;
        this.gasCost = gasCost;
    }
    get finishTime() {
        return this.startTime + this.duration;
    }
    static fromAuctionData(data, details) {
        return new AuctionCalculator(details.startTime, details.duration, details.initialRateBump, details.points, data.integratorFee?.ratio || 0n, details.gasCost);
    }
    static calcInitialRateBump(startAmount, endAmount) {
        const bump = (constants_1.RATE_BUMP_DENOMINATOR * startAmount) / endAmount -
            constants_1.RATE_BUMP_DENOMINATOR;
        return Number(bump);
    }
    /**
     * Important!: method implementation is different from contract implementation
     * Because of that, sdk amount can be less than contract amount by 1 wad
     *
     * @see https://github.com/1inch/limit-order-settlement/blob/2eef6f86bf0142024f9a8bf054a0256b41d8362a/contracts/extensions/BaseExtension.sol#L66
     */
    static calcAuctionTakingAmount(takingAmount, rate, takerFeeRatio) {
        const auctionTakingAmount = (BigInt(takingAmount) * (BigInt(rate) + constants_1.RATE_BUMP_DENOMINATOR)) /
            constants_1.RATE_BUMP_DENOMINATOR;
        if (takerFeeRatio === 0n) {
            return auctionTakingAmount;
        }
        return (0, sdk_1.addRatioToAmount)(auctionTakingAmount, takerFeeRatio);
    }
    /**
     * Encode estimation `baseFee` as `gasPriceEstimate` for `AuctionGasCostInfo`
     */
    static baseFeeToGasPriceEstimate(baseFee) {
        return baseFee / AuctionCalculator.GAS_PRICE_BASE;
    }
    /**
     * Calculates `gasBumpEstimate` for `AuctionGasCostInfo`
     *
     * @param endTakingAmount min return in destToken
     * @param gasCostInToToken gas cost in destToken
     */
    static calcGasBumpEstimate(endTakingAmount, gasCostInToToken) {
        return (gasCostInToToken * constants_1.RATE_BUMP_DENOMINATOR) / endTakingAmount;
    }
    calcAuctionTakingAmount(takingAmount, rate) {
        return AuctionCalculator.calcAuctionTakingAmount(takingAmount, rate, this.takerFeeRatio);
    }
    /**
     * @see https://github.com/1inch/limit-order-settlement/blob/273defdf7b0f1867299dcbc306f32f035579310f/contracts/extensions/BaseExtension.sol#L121
     * @param time auction timestamp in seconds
     * @param blockBaseFee blockBaseFee in Wei, if passed, then rate will be calculated as if order executed in block with `blockBaseFee`
     */
    calcRateBump(time, blockBaseFee = 0n) {
        const gasBump = this.getGasPriceBump(blockBaseFee);
        const auctionBump = this.getAuctionBump(time);
        const final = auctionBump > gasBump ? auctionBump - gasBump : 0n;
        return Number(final);
    }
    getGasPriceBump(blockBaseFee) {
        if (this.gasCost.gasBumpEstimate === 0n ||
            this.gasCost.gasPriceEstimate === 0n ||
            blockBaseFee === 0n) {
            return 0n;
        }
        return ((this.gasCost.gasBumpEstimate * blockBaseFee) /
            this.gasCost.gasPriceEstimate /
            AuctionCalculator.GAS_PRICE_BASE);
    }
    getAuctionBump(blockTime) {
        const auctionFinishTime = this.finishTime;
        if (blockTime <= this.startTime) {
            return this.initialRateBump;
        }
        else if (blockTime >= auctionFinishTime) {
            return 0n;
        }
        let currentPointTime = this.startTime;
        let currentRateBump = this.initialRateBump;
        for (const { coefficient: nextRateBump, delay } of this.points) {
            const nextPointTime = BigInt(delay) + currentPointTime;
            if (blockTime <= nextPointTime) {
                return (((blockTime - currentPointTime) * BigInt(nextRateBump) +
                    (nextPointTime - blockTime) * currentRateBump) /
                    (nextPointTime - currentPointTime));
            }
            currentPointTime = nextPointTime;
            currentRateBump = BigInt(nextRateBump);
        }
        return (((auctionFinishTime - blockTime) * currentRateBump) /
            (auctionFinishTime - currentPointTime));
    }
}
exports.AuctionCalculator = AuctionCalculator;
AuctionCalculator.GAS_PRICE_BASE = 1000000n; // 1000 means 1 Gwei
//# sourceMappingURL=auction-calculator.js.map