"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuctionDetails = void 0;
const ethers_1 = require("ethers");
const byte_utils_1 = require("@1inch/byte-utils");
const assert_1 = __importDefault(require("assert"));
const validations_1 = require("../../validations");
const utils_1 = require("../../utils");
const constants_1 = require("../../constants");
class AuctionDetails {
    constructor(auction) {
        this.startTime = BigInt(auction.startTime);
        this.initialRateBump = BigInt(auction.initialRateBump);
        this.duration = auction.duration;
        this.points = auction.points;
        this.gasCost = auction.gasCost || {
            gasBumpEstimate: 0n,
            gasPriceEstimate: 0n
        };
        (0, assert_1.default)(this.gasCost.gasBumpEstimate <= constants_1.UINT_24_MAX);
        (0, assert_1.default)(this.gasCost.gasPriceEstimate <= constants_1.UINT_32_MAX);
        (0, assert_1.default)(this.startTime <= constants_1.UINT_32_MAX);
        (0, assert_1.default)(this.duration <= constants_1.UINT_24_MAX);
        (0, assert_1.default)(this.initialRateBump <= constants_1.UINT_24_MAX);
    }
    /**
     * Construct `AuctionDetails` from bytes
     *
     * @param data bytes with 0x prefix in next format:
     * - uint24 gasBumpEstimate
     * - uint32 gasPriceEstimate
     * - uint32 startTime
     * - uint24 duration
     * - uint24 initialRateBump
     * - [uint24 rate, uint16 delay] * N points
     *
     * All data is tight packed
     *
     * @see AuctionDetails.encode
     */
    static decode(data) {
        (0, assert_1.default)((0, validations_1.isHexBytes)(data), 'Invalid auction details data');
        const iter = byte_utils_1.BytesIter.BigInt(data);
        const gasBumpEstimate = iter.nextUint24();
        const gasPriceEstimate = iter.nextUint32();
        const start = iter.nextUint32();
        const duration = iter.nextUint24();
        const rateBump = Number(iter.nextUint24());
        const points = [];
        while (!iter.isEmpty()) {
            points.push({
                coefficient: Number(iter.nextUint24()),
                delay: Number(iter.nextUint16())
            });
        }
        return new AuctionDetails({
            startTime: start,
            duration: duration,
            initialRateBump: rateBump,
            points,
            gasCost: {
                gasBumpEstimate,
                gasPriceEstimate
            }
        });
    }
    static fromExtension(extension) {
        return AuctionDetails.decode((0, utils_1.add0x)(extension.makingAmountData.slice(42)));
    }
    /**
     * Serialize auction data to bytes
     */
    encode() {
        let details = ethers_1.ethers.solidityPacked(['uint24', 'uint32', 'uint32', 'uint24', 'uint24'], [
            this.gasCost.gasBumpEstimate,
            this.gasCost.gasPriceEstimate,
            this.startTime,
            this.duration,
            this.initialRateBump
        ]);
        for (let i = 0; i < this.points.length; i++) {
            details += (0, utils_1.trim0x)(ethers_1.ethers.solidityPacked(['uint24', 'uint16'], [this.points[i].coefficient, this.points[i].delay]));
        }
        return details;
    }
}
exports.AuctionDetails = AuctionDetails;
//# sourceMappingURL=auction-details.js.map