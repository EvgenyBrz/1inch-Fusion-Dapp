import { Address, Extension } from '@1inch/limit-order-sdk';
import { IntegratorFee, SettlementSuffixData } from './types';
export declare class SettlementPostInteractionData {
    readonly whitelist: WhitelistItem[];
    readonly integratorFee?: IntegratorFee;
    readonly bankFee: bigint;
    readonly resolvingStartTime: bigint;
    readonly customReceiver?: Address;
    private constructor();
    static new(data: SettlementSuffixData): SettlementPostInteractionData;
    /**
     * Construct `SettlementPostInteractionData` from bytes
     * @param data bytes with 0x prefix in next format:
     * - [uint32 feeBank] only when first bit of `bitMask` enabled
     * - [uint16 integratorFeeRation, uint160 integratorFeeReceiver, [uint160 customReceiver]] only when second bit of `bitMask` enabled
     * - uint32 auctionStartTime
     * - (bytes10 last10bytesOfAddress, uint16 auctionDelay) * N whitelist info
     * - uint8 bitMask:
     *                  0b0000_0001 - fee bank mask
     *                  0b0000_0010 - integrator fee mask
     *                  0b0000_0100 - is custom receiver present (only used when integrator fee enabled)
     *                  0b1111_1000 - resolvers count mask
     *
     * All data is tight packed
     * @see SettlementPostInteractionData.encode
     */
    static decode(data: string): SettlementPostInteractionData;
    static fromExtension(extension: Extension): SettlementPostInteractionData;
    /**
     * Serialize post-interaction data to bytes
     */
    encode(): string;
    /**
     * Check whether address allowed to execute order at the given time
     *
     * @param executor address of executor
     * @param executionTime timestamp in sec at which order planning to execute
     */
    canExecuteAt(executor: Address, executionTime: bigint): boolean;
    isExclusivityPeriod(time?: bigint): boolean;
    isExclusiveResolver(wallet: Address): boolean;
}
type WhitelistItem = {
    /**
     * last 10 bytes of address, no 0x prefix
     */
    addressHalf: string;
    /**
     * Delay from previous resolver in seconds
     * For first resolver delay from `resolvingStartTime`
     */
    delay: bigint;
};
export {};
